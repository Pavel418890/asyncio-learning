- This module is used to hide all the complexity of dealing with I/O polling via direct sys calls such as
  epoll/devpoll/poll/select/kqueue and also provide a mechanism to attach a callback to an fd tracked by a 'poller'
  object. epoll/devpoll/poll/select/kqueue mechanisms are provided by the Python's `select` module which interfaces with
  the underlying OS C/C++ APIs of those sys calls.

- Provides a high level structure in the form of namedtuple called `SelectorKey` in which it stores the following
  attributes in the following order:
  1. <original file object>,
  2. <original file object's fd>,
  3. <events bitmask (for which particular events this fd is to be tracked for - read, write, or read and write),
  4. <any data associated with the fd, usually a callback that can be called when an I/O event occurs on the fd>

- Exposes a DefaultSelector class which provides all the high level APIs for managing non-blocking I/O and which is most
  fit for the current system. Could be:
    - EpollSelector (preferred for Unix and is supoorted by Unix only),
    - DevpollSelector (preferred for Solaris),
    - PollSelector (used for Unix if epoll is not available),
    - SelectSelector (Unix if epoll/poll are not available + is the only option Windows, no IOCP support for Windows here)
    - KqueueSelector (MacOS)

- Uses some module level constants (EVENT_READ = 1, EVENT_WRITE = 2) for event bitmasks, which provide a unified
  interface to the client for specifying the I/O events they want a particular fd to be polled for.
  This hides the implementation specific event bitmasks providing a unified API:
        - POLLIN, POLLOUT for poll and devpoll
        - EPOLLIN, EPOLLOUT for epoll
        - Kevents with KQ_FILTER_READ and KQ_FILTER_WRITE params in case of kqueue
        - Select doesn't need any event bitmasks at all

- Selector class implementation details:

    1) On init creates an empty mapping of fds to SelectorKeys, constructs and stores a special _SelectorMapping
       which overrides its `__getitem__`, `__len__` and `__iter__` methods: `__len__` returns the number of fds
       currently registered with the selector, `__iter__` lets you iterate over all of the fds currently registered,
       `__getitem__` transforms a possible file-like object to its underlying fd and using that fd retrieves and returns
       the corresponding SelectorKey. This _SelectorMapping can be retrieved using the selector's `.get_map()` method.
       Different selector classes also perform some additional setup after this as well.

            - SelectSelector also sets up empty `._readers` and `._writers` sets where it will store its fds to
              poll for I/O events.

            - EpollSelector/DevpollSelector/PollSelector instantiate their underlying epoll/devpoll/poll control objects
              for later use when polling for I/O.

            - KqueueSelector instantiates its kernel event kqueue (kqueue) for later use when polling for I/O.

    2) To register an fd or file-like object to be tracked by the selector you must call it's `.register()` method.
       Regardless of the selector type being used, this method creates a `SelectorKey` storing and associating it
       with the file-objects raw fd within an instance attribute-mapping called `._fd_to_key`.
       This `._fd_to_key` mapping is later going to be used during I/O polling (`.select()` method calls) to get
       the associated SelectorKey with data/callback associated with each fd on which an I/O event occurred.

       Let's add some more details about each selector type additions to this method.
            - SelectSelector also adds the fd to a `._readers` or/and `._writers` sets depending on the event mask
              passed in, constructed from the globally provided EVENT_READ and EVENT_WRITE constants.
              Basically depending on the events for which the fd was requested to be tracked for.
              These sets are going to be used while polling for I/O by passing them as reader and writer lists
              to the underlying 'select' call.

            - _PollLikeSelector (epoll/devpoll/poll) converts the client constructed event bitmask from globally provided
               EVENT_READ and EVENT_WRITE constants to event bitmasks supported natively by epoll, poll and devpoll
               and calculates their native bitmask to ensure that fds are polled for the right client-requested events.
               After that it performs a sys call on the control epoll/devpoll/poll object to register
               the fd to be polled for the client-requested I/O events.
               Later on, these are going to be the fds that will be polled for I/O.

            - KqueueSelector depending on the event bitmask constructed from the globally provided EVENT_READ and
              EVENT_WRITE constants does a sys call to create read and/or write kernel event 'kevent' object/objects
              using the client-provided fd. After that it registers the 'kevent' object/objects with the kernel
              event 'kqueue' by calling `.control()` on it also requiring and additional sys call/sys calls.
              Later on, these are going to be the fds that will be polled for I/O.

    3) To stop polling an fd for I/O, i.e. unregister it from the selector, the `.unregister()` method is used.
       Regardless of the selector type being used, this method just pops the SelectorKey associated with the fd
       and returns it (basically the fd is no longer being tracked at least at the application level).

            - SelectSelector also removes the fd from the `._readers` and `._writers` underlying sets.

            - EpollSelector/PollSelector/DevpollSelector also just unregisters the fd from being tracked for I/O
              events by the underlying epoll/poll/devpoll control object.

            - KqueueSelector creates 1 or 2 'kevent' objects with the 'KQ_EV_DELETE' command depending on, whether the
              fd was registered to be polled for read and/or write I/O events. After that each 'kevent' control object
              is removed from the kernel event queue (kqueue) via it's `.control()` method call - basically the fd
              is no longer polled for read and/or write I/O events by the selector.

    4) To update the I/O events that an already registered fd is tracked for or the data/callback associated with
       the fd's I/O events the `.modify()` method is used:

            - SelectSelector/KqueueSelector validates that the fd has indeed been previously registered, otherwise
              raises a KeyError. Updates of I/O events that the fd should be tracked for are handled separately from
              updating the associated data/callback:
                    a) If the events mask is requested to be updated, meaning the client wants to track the fd for
                       some different events/event the fd is first unregistered and then registered again from scratch
                       with the new event mask - for reference check out the section how `.register()` and
                       `.unregister()` are handled by SelectSelector and KqueueSelector

                    b) If the data/callback associated with the fd's I/O event was requested to be updated then it
                       is just replaced within the SelectorKey namedtuple associated with the fd (in reality
                       a new SelectorKey namedtuple is associated with the fd, because tuples are immutable).

            - EpollSelector/DevpollSelector/PollSelector that the fd has indeed been previously registered, otherwise
              raises a KeyError. Updates of I/O events that the fd should be tracked for are handled separately from
              updating the associated data/callback:
                    a) If the events bitmask is requested to be updated, meaning the client wants to track the fd for
                       some different events/event, the event bitmask is first transformed to the native
                       epoll/devpoll/poll bitmask.
                       After that the native event bitmask is updated so that the original fd will be ready to support
                       the newly requested events and after that is applied to the already tracked fd via calling
                       the `.modify()` method on the underlying selector, which may do this update in place
                       under the hood, depending on the polling mechanism that's being used. Is more efficient than
                       registering and unregistering the same fd with a new event bitmask.

                    b) If the data/callback associated with the fd's I/O event was requested to be updated then it
                       is just replaced within the SelectorKey namedtuple associated with the fd (in reality
                       a new SelectorKey namedtuple is associated with the fd, because tuples are immutable).

    5) To perform I/O polling on the registered fd the `.select()` method is used.
            - SelectSelector polls with or without timeout all the fds currently present in its `._readers`
              and `._writers` lists (previously registered) for I/O using the 'select' sys call passing
              it those lists of fds.
              After the sys call returns the method may receive 2 separate sets of fds corresponding to
              read/write-events, it keeps them but at the same time unions those 2 sets into a
              new set containing all of the returned fds. By iterating over the new set it calculates an event mask
              for each returned fd using the global EVENT_READ and EVENT_WRITE constants depending on whether an fd is
              present in the set of read-ready and/or write-ready fd sets. It also retrieves the fd's associated
              SelectorKey namedtuple (which contains the associated data or callback). Finally it calculates the
              final event mask for the fd - for example, a client only requested the fd to be tracked for read events,
              but a write and read event occurred on the fd, only the read event mask will be kept.
              Returns a list of tuples each one containing the associated SelectorKey and requested
              event mask corresponding to an I/O event. If the requested I/O event didn't occur on a particular fd
              the event mask will be 0.

            - PollSelector/DevpollSelector first converts the passed in timeout to milliseconds if necessary (polling
              objects expect the timout to be provided in millisecond resolution). After that it calls the
              'poll' sys call which polls all the previously registered fds for I/O events taking the timeout
              into account. When the sys call completes it returns a possibly-empty list of tuples containing
              (fd, event). After that for each returned fd converts the native poll/devpoll event masks
              (POLLIN and POLLOUT) to the module provided masks - EVENT_READ and EVENT_WRITE constants.
              Calculates the final event mask this time already using the non-native poll event masks for the fd -
              for example, a client only requested the fd to be tracked for read events, but a write and read event
              occurred on the fd, only the read event mask will be kept.
              Returns a list of tuples each one containing the associated SelectorKey and requested
              event mask corresponding to an I/O event. If the requested I/O event didn't occur on a particular fd
              the event mask will be 0.

            - EpollSelector first converts the passed in timeout to milliseconds if necessary (epoll polling
              objects expect the timeout to be provided in millisecond resolution). Ensure that epoll polls for
              all the currently registered fds - epoll expects a `maxevents` param after which it will wait no longer,
              so it should be set to the count of all currently registered fds or a least 1 if there are no fds
              registered yet. After that it calls the `epoll_wait` sys call which polls all the previously registered
              fds for I/O events taking the timeout into account. When the sys call completes
              it returns a possibly-empty list of tuples containing (fd, event).
              After that for each returned fd converts the native epoll event masks (EPOLLIN and EPOLLOUT) to
              the module provided masks - EVENT_READ and EVENT_WRITE constants.
              Calculates the final event mask this time already using the non-native epoll event masks for the fd -
              for example, a client only requested the fd to be tracked for read events, but a write and read event
              occurred on the fd, only the read event mask will be kept.
              Returns a list of tuples each one containing the associated SelectorKey and requested
              event mask corresponding to an I/O event. If the requested I/O event didn't occur on a particular fd
              the event mask will be 0.

            - KqueueSelector ensures that `max_ev` is set to either 1 or the current count of all registered fds, so
              that the polling timeout parameter won't be ignored. After that it does a polls of I/O using the
              'control' call (maybe sys call) which in the ned returns a list of kevent objects. For very kevent in the
              list it checks what I/O events are associated with it - read and/or write. After that for each kevent its
              corresponding fd is retrieved and the final events mask is calculated for each of those fds using
              EVENT_READ and EVENT_WRITE constants.
              Calculates the final event mask this time already not taking kevent objects into account - for example,
              a client only requested the fd to be tracked for read events, but a write and read event occurred on the
              fd, only the read event mask will be kept.
              Returns a list of tuples each one containing the associated SelectorKey and requested
              event mask corresponding to an I/O event. If the requested I/O event didn't occur on a particular fd
              the event mask will be 0.

    6) To close the selector and free its underlying resources the `.close()` method is used:

            - SelectSelector/PollSelector just clears the fd to SelectorKey mapping and sets its `._map` attribute
              to None which was used to retrieve SelectorKeys by their corresponding file-like objects.

            - EpollSelector closes the control fd of the epoll object and after that clears the fd to SelectorKey
              mapping and sets its `._map` attribute to None which was used to retrieve SelectorKeys by their
              corresponding file-like objects.

            - DevpollSelector closes the control fd of the devpoll object and after that clears the fd to SelectorKey
              mapping and sets its `._map` attribute to None which was used to retrieve SelectorKeys by their
              corresponding file-like objects.

            - KqueueSelector closes the control fd of the kqueue (kernel event queue) object and after
              that clears the fd to SelectorKey mapping and sets its `._map` attribute to None which was used to
              retrieve SelectorKeys by their corresponding file-like objects.

    7) You can retrieve a SelectorKey namedtuple corresponding to a fileobj/fd via the `.get_key()` method.
       It retrieves the possible file-like object's fd an then using that fd returns its corresponding SelectorKey
       (is accomplished through the underlying _SelectorMapping instance).

    8) EpollSelector, DevpollSelector and KqueueSelector also allow you to retrieve the fd of their underlying
       control objects via the `.fileno()` method.